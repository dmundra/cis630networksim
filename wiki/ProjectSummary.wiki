=CIS 630 Project Status Summary=

==Project==
Network Simulation

==Description==
Goal of the project is to simulate a network with computers
and routers and messages being send and received between them.

==Project Evolution==
Simulation of a botnet was our initial goal.  In order to contain and run a botnet, we chose to implement a distributed network simulation.  Due to the complexity of the process, building a network simulation became a project in itself and the botnet fell by the wayside.  Within the network simulation framework we were able to implement the Token Ring Algorithm and the Bully Algorithm which employs Lamport's clock. 

==Network Simulator==
We have a hierarchy of interfaces that represent
  * Kernel - Logic responsible for handling routing and messaging
  * Nodes - A machine on the network. May be either a router or a leaf node.
  * Processes - The software loaded into a node.
  * Operating System - The API for the OS to send and receive messages and run processes
  * Simulator - The main control interface to the simulation. From here, nodes are created, destroyed, and manipulated at will.
  
With that we have classes that represent
  * Interface Implementations - [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/impl/kernel/KernelImpl.java KernelImpl], [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/impl/NodeImpl.java NodeImpl], and etc.
  * Protocols - [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/protocols/HTTP.java HTTP protocol]
  * Software - [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/software/HTTPServer.java HTTPServer]
  * Test Programs - [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/CountingTest.java CountingTest], [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/HTTPServerTest.java HTTPServerTest], [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/KernelUserTest.java KernelUserTest]
  
==Tests==
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/BullyTest.java BullyTest]  - Test of network which implements the Bully Algorithm for establishing control.  The Bully Algorithm uses Lamport Clocks for the election process.
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/TokenRingTwoPhaseTest.java TokenRingTwoPhaseTest] - Test of network which implements the Ring Algorithm for establishing control.
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/CountingTest.java CountingTest] - Test two nodes connected to each other where one node sends a number the other one receives it, increments it and sends it back.
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/CountingProcessTest.java CoutingProcessTest] - Same as above but uses processes to send and receive messages
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/HTTPServerTest.java HTTPServerTest] - Test of client-server http model
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/KernelUserTest.java KernelUserTest] - Test of simple network simulation of routers and computers
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/MultiProcessTest.java MultiProcessTest] - Tests if multiple processes can be running on the operating system.
  * [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/SimpleTestRun.java SimpleTestRun] - Tests if the nodes are being created correctly.

==Other Notes==
We are using TestNG to test are code. We have implemented Java Logger in all our classes to use for logging.

== Why our interface is useful to simulate a distributed system ==
Our network simulator is useful representation of real world networks and can be set-up in any configuration which physical networks exist.  The Nodes, which represent routers and computers, run independent of each other. Encapsulation of data and code forces the user to obey the normal physical constraints of contacting other nodes through "wired" connections rather than just accessing the information. 

* [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/impl/kernel/KernelImpl.java RIP Algorithm] *
  
  [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/impl/kernel/KernelImpl.java KernelImpl] is an implementation of a Kernel that is designed to run a router. These routers send a message to all of their neighbors (directly connected nodes) requesting routing information. When routing information is received, we compare it against our table to see if we need to add to/update our table. Entries are only removed from our table when a message is unsuccessfully sent (we assume a dead connection somewhere along the way).  

* [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/BullyTest.java Bully Algorithm] on a simulated DS:

  We tested a bully algorithm by simulating a network with five computers and two routers. Each computer has one process that is participating in the network by sending information (an almost empty message) to the elected leader. The leader then replies with an acknowledgment of receipt. 

  If a process never receives an acknowledgment from its leader it calls an election (by requesting votes from its superiors). If a vote is received, the process begins to wait for an announcement from the new leader (as there exists a superior to this process). If no superiors respond, the process declares itself the leader and sends the message to all participating processes.  

  Each process has a logical election clock. This clock represents that most current election that this process knows about. When a process calls an election, it increments the clock and begins sending the messages. When an election related message is received, the election clock is checked to see if the message relevant (i.e. not from an old election). The use of the election clocks enabled us to have multiple processes calling elections concurrently while still arriving at a single result. 

  When a new process...

* [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/TokenRingTwoPhaseTest.java Two Phase Commit] on a simulated DS:

  Nodes on a token ring are logically organized in a ring topology with data being transmitted sequentially from one node to the next with a control token circulating around the ring controlling access.  The logical topology is used for the two phase process of voting and commit/abort.  

  In our example we have 5 nodes connected with two routers. We setup each node to have the address of the next node with the last node pointing back to the first node forming the ring. When we start the program the first node is set to be the one who wants to commit and they pass a token to the next node asking to commit. The next node will either accept it or reject it by putting its answer in the token and passing it along to the next node. After this is done for all nodes the node that asked to commit will get back the token and they can check it to see if anyone rejected the commit request. If everyone accepted or someone rejected the commit request the node will then send another token that will contain whether it aborted or it was a success. After that token comes back acknowledging everyone received the message of abort or success the node will then send a up for grabs token which says that now someone else can send a commit request by taking the up for grabs token and sending a commit request token and the we repeat the two phase token sending. 
 
  Our test simulation allows the user to set the likelihood nodes will not agree to the commit request as well as the likelihood a node will want a token that is up for grabs.      


==Project Contributions==
  * Anthony
  * Daniel: I worked on initial project description of simulating a botnet with the rest of the team. Worked with Anthony and Kristy to develop the [http://code.google.com/p/cis630networksim/source/browse/trunk/src/network/impl/kernel/KernelImpl.java KernelImpl] method that manages how routers perform the RIP algorithm and manage message routing. Created the [http://code.google.com/p/cis630networksim/source/browse/trunk/src/test/TokenRingTwoPhaseTest.java Two Phase Commit] test case and worked with Anthony and Kristy to improve it.
  * Kristy
  * Luke